<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Tetris</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body {
  background: #020a14;
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: 100vh;
  font-family: 'Courier New', monospace;
  color: #fff;
  overflow: hidden;
  position: relative;
}
/* === PANDORA BACKGROUND === */
#pandora-bg {
  position: fixed;
  top: 0; left: 0;
  width: 100%; height: 100%;
  z-index: 0;
  pointer-events: none;
}
.game-wrapper, #start-screen, #game-over { position: relative; z-index: 2; }
.game-wrapper {
  display: flex;
  gap: 24px;
  align-items: flex-start;
}
.side-panel {
  display: flex;
  flex-direction: column;
  gap: 16px;
  min-width: 120px;
}
.panel-box {
  background: rgba(5, 15, 30, 0.85);
  border: 2px solid rgba(0, 200, 255, 0.3);
  border-radius: 8px;
  padding: 12px;
  text-align: center;
  box-shadow: 0 0 12px rgba(0, 180, 255, 0.1);
}
.panel-box h3 {
  font-size: 11px;
  color: #888;
  text-transform: uppercase;
  letter-spacing: 2px;
  margin-bottom: 8px;
}
.panel-box .value {
  font-size: 24px;
  font-weight: bold;
  color: #fff;
}
#next-canvas {
  display: block;
  margin: 0 auto;
}
canvas#game {
  border: 2px solid rgba(0, 200, 255, 0.3);
  border-radius: 4px;
  background: rgba(5, 10, 25, 0.8);
  box-shadow: 0 0 20px rgba(0, 180, 255, 0.15), inset 0 0 40px rgba(0, 100, 200, 0.05);
}
.controls {
  font-size: 11px;
  color: #555;
  text-align: center;
  margin-top: 12px;
}
.controls span { color: #888; }
#game-over {
  display: none;
  position: absolute;
  top: 50%; left: 50%;
  transform: translate(-50%, -50%);
  background: rgba(0,0,0,0.92);
  padding: 40px;
  border-radius: 12px;
  border: 2px solid #f00;
  text-align: center;
  z-index: 10;
}
#game-over h2 { color: #f44; font-size: 28px; margin-bottom: 8px; }
#game-over p { color: #aaa; margin-bottom: 16px; }
#game-over button {
  background: #f44;
  color: #fff;
  border: none;
  padding: 10px 28px;
  font-size: 16px;
  border-radius: 6px;
  cursor: pointer;
  font-family: inherit;
}
#game-over button:hover { background: #f66; }
#start-screen {
  position: absolute;
  top: 50%; left: 50%;
  transform: translate(-50%, -50%);
  text-align: center;
  z-index: 10;
}
#start-screen h1 {
  font-size: 48px;
  background: linear-gradient(90deg, #00e5ff, #00ff87, #b388ff, #00e5ff);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  margin-bottom: 16px;
  text-shadow: 0 0 40px rgba(0, 200, 255, 0.5);
  animation: titleGlow 3s ease-in-out infinite;
}
@keyframes titleGlow {
  0%, 100% { filter: brightness(1); }
  50% { filter: brightness(1.3); }
}
#start-screen button {
  background: rgba(0, 180, 255, 0.15);
  color: #00e5ff;
  border: 2px solid rgba(0, 200, 255, 0.5);
  padding: 12px 36px;
  font-size: 18px;
  border-radius: 8px;
  cursor: pointer;
  font-family: inherit;
  text-shadow: 0 0 8px rgba(0, 200, 255, 0.5);
  transition: all 0.3s;
}
#start-screen button:hover { background: rgba(0, 180, 255, 0.3); border-color: #00e5ff; box-shadow: 0 0 20px rgba(0, 200, 255, 0.3); }
.mobile-controls {
  display: none;
  justify-content: center;
  gap: 12px;
  margin-top: 16px;
}
.mobile-controls button {
  width: 56px; height: 56px;
  font-size: 22px;
  background: #222;
  color: #fff;
  border: 2px solid #444;
  border-radius: 10px;
  cursor: pointer;
  -webkit-tap-highlight-color: transparent;
}
@media (max-width: 600px) {
  .game-wrapper { flex-direction: column; align-items: center; gap: 12px; }
  .side-panel { flex-direction: row; flex-wrap: wrap; justify-content: center; }
  canvas#game { width: 240px; height: 480px; }
  .mobile-controls { display: flex; }
}
</style>
</head>
<body>

<canvas id="pandora-bg"></canvas>

<div id="start-screen">
  <h1>TETRIS</h1>
  <button onclick="startGame()">START</button>
</div>

<div id="game-over">
  <h2>GAME OVER</h2>
  <p>Score: <span id="final-score">0</span></p>
  <button onclick="startGame()">PLAY AGAIN</button>
</div>

<div class="game-wrapper" style="visibility:hidden" id="game-area">
  <div class="side-panel">
    <div class="panel-box">
      <h3>Score</h3>
      <div class="value" id="score">0</div>
    </div>
    <div class="panel-box">
      <h3>Level</h3>
      <div class="value" id="level">1</div>
    </div>
    <div class="panel-box">
      <h3>Lines</h3>
      <div class="value" id="lines">0</div>
    </div>
    <div class="panel-box">
      <h3>Next</h3>
      <canvas id="next-canvas" width="80" height="80"></canvas>
    </div>
  </div>
  <div>
    <canvas id="game" width="300" height="600"></canvas>
    <div class="controls">
      <span>←→</span> Move &nbsp; <span>↑</span> Rotate &nbsp; <span>↓</span> Soft Drop &nbsp; <span>Space</span> Hard Drop &nbsp; <span>P</span> Pause
    </div>
    <div class="mobile-controls">
      <button ontouchstart="moveLeft()" onclick="moveLeft()">←</button>
      <button ontouchstart="rotate()" onclick="rotate()">↻</button>
      <button ontouchstart="softDrop()" onclick="softDrop()">↓</button>
      <button ontouchstart="hardDrop()" onclick="hardDrop()">⤓</button>
      <button ontouchstart="moveRight()" onclick="moveRight()">→</button>
    </div>
  </div>
</div>

<script>
// === PANDORA BACKGROUND ===
(function() {
  const bg = document.getElementById('pandora-bg');
  const bc = bg.getContext('2d');
  let W, H;
  function resize() { W = bg.width = window.innerWidth; H = bg.height = window.innerHeight; }
  resize();
  window.addEventListener('resize', resize);

  // Floating particles (bioluminescent spores)
  const particles = [];
  for (let i = 0; i < 120; i++) {
    particles.push({
      x: Math.random() * 2000, y: Math.random() * 1200,
      r: Math.random() * 3 + 1,
      dx: (Math.random() - 0.5) * 0.4,
      dy: -Math.random() * 0.5 - 0.1,
      hue: Math.random() > 0.5 ? 180 + Math.random() * 40 : 270 + Math.random() * 40,
      alpha: Math.random() * 0.6 + 0.2,
      pulse: Math.random() * Math.PI * 2
    });
  }

  // Bioluminescent plants
  const plants = [];
  for (let i = 0; i < 18; i++) {
    plants.push({
      x: Math.random() * 2000,
      h: Math.random() * 200 + 80,
      sway: Math.random() * Math.PI * 2,
      hue: [180, 200, 260, 280, 300][Math.floor(Math.random() * 5)],
      width: Math.random() * 3 + 1
    });
  }

  // Glowing mushrooms
  const shrooms = [];
  for (let i = 0; i < 8; i++) {
    shrooms.push({
      x: Math.random() * 2000,
      size: Math.random() * 30 + 15,
      hue: Math.random() > 0.5 ? 180 : 280,
      pulse: Math.random() * Math.PI * 2
    });
  }

  let t = 0;
  function drawPandora() {
    t += 0.008;
    bc.clearRect(0, 0, W, H);

    // Sky gradient - deep alien night
    const sky = bc.createLinearGradient(0, 0, 0, H);
    sky.addColorStop(0, '#020818');
    sky.addColorStop(0.3, '#041230');
    sky.addColorStop(0.6, '#061a3a');
    sky.addColorStop(0.85, '#0a2844');
    sky.addColorStop(1, '#0d3050');
    bc.fillStyle = sky;
    bc.fillRect(0, 0, W, H);

    // Stars
    bc.fillStyle = '#fff';
    for (let i = 0; i < 80; i++) {
      const sx = (i * 137.5 + i * i * 3.7) % W;
      const sy = (i * 89.3 + i * 7.1) % (H * 0.5);
      const sa = 0.3 + 0.4 * Math.sin(t * 2 + i);
      bc.globalAlpha = sa;
      bc.beginPath();
      bc.arc(sx, sy, 0.8, 0, Math.PI * 2);
      bc.fill();
    }
    bc.globalAlpha = 1;

    // Giant planet/moon in sky
    const moonX = W * 0.75, moonY = H * 0.18, moonR = 60;
    const moonGrad = bc.createRadialGradient(moonX - 10, moonY - 10, moonR * 0.1, moonX, moonY, moonR);
    moonGrad.addColorStop(0, 'rgba(150, 200, 255, 0.3)');
    moonGrad.addColorStop(0.5, 'rgba(80, 140, 220, 0.15)');
    moonGrad.addColorStop(1, 'rgba(40, 80, 160, 0)');
    bc.fillStyle = moonGrad;
    bc.beginPath();
    bc.arc(moonX, moonY, moonR, 0, Math.PI * 2);
    bc.fill();
    // moon glow
    const moonGlow = bc.createRadialGradient(moonX, moonY, moonR, moonX, moonY, moonR * 3);
    moonGlow.addColorStop(0, 'rgba(100, 180, 255, 0.06)');
    moonGlow.addColorStop(1, 'rgba(100, 180, 255, 0)');
    bc.fillStyle = moonGlow;
    bc.beginPath();
    bc.arc(moonX, moonY, moonR * 3, 0, Math.PI * 2);
    bc.fill();

    // Mountain silhouettes
    bc.fillStyle = '#060e1a';
    bc.beginPath();
    bc.moveTo(0, H);
    bc.lineTo(0, H * 0.55);
    bc.lineTo(W * 0.1, H * 0.45);
    bc.lineTo(W * 0.2, H * 0.55);
    bc.lineTo(W * 0.3, H * 0.4);
    bc.lineTo(W * 0.45, H * 0.52);
    bc.lineTo(W * 0.55, H * 0.38);
    bc.lineTo(W * 0.7, H * 0.5);
    bc.lineTo(W * 0.8, H * 0.42);
    bc.lineTo(W * 0.9, H * 0.48);
    bc.lineTo(W, H * 0.5);
    bc.lineTo(W, H);
    bc.fill();

    // Ground
    const ground = bc.createLinearGradient(0, H * 0.7, 0, H);
    ground.addColorStop(0, '#081820');
    ground.addColorStop(1, '#0a2018');
    bc.fillStyle = ground;
    bc.fillRect(0, H * 0.7, W, H * 0.3);

    // Bioluminescent plants
    for (const p of plants) {
      const sway = Math.sin(t + p.sway) * 15;
      const baseX = p.x % W;
      const baseY = H;
      bc.strokeStyle = `hsla(${p.hue}, 100%, 60%, 0.4)`;
      bc.lineWidth = p.width;
      bc.shadowColor = `hsla(${p.hue}, 100%, 60%, 0.6)`;
      bc.shadowBlur = 15;
      bc.beginPath();
      bc.moveTo(baseX, baseY);
      bc.quadraticCurveTo(baseX + sway, baseY - p.h * 0.6, baseX + sway * 1.5, baseY - p.h);
      bc.stroke();
      // tip glow
      bc.fillStyle = `hsla(${p.hue}, 100%, 70%, ${0.4 + 0.3 * Math.sin(t * 2 + p.sway)})`;
      bc.beginPath();
      bc.arc(baseX + sway * 1.5, baseY - p.h, 4, 0, Math.PI * 2);
      bc.fill();
      bc.shadowBlur = 0;
    }

    // Glowing mushrooms
    for (const s of shrooms) {
      const sx = s.x % W;
      const sy = H - 20;
      const glow = 0.3 + 0.2 * Math.sin(t * 1.5 + s.pulse);
      // stem
      bc.fillStyle = `hsla(${s.hue}, 60%, 25%, 0.6)`;
      bc.fillRect(sx - 2, sy - s.size * 0.6, 4, s.size * 0.6);
      // cap
      bc.fillStyle = `hsla(${s.hue}, 100%, 55%, ${glow})`;
      bc.shadowColor = `hsla(${s.hue}, 100%, 60%, 0.8)`;
      bc.shadowBlur = 20;
      bc.beginPath();
      bc.ellipse(sx, sy - s.size * 0.6, s.size * 0.5, s.size * 0.3, 0, Math.PI, 0);
      bc.fill();
      bc.shadowBlur = 0;
    }

    // Floating spores/particles
    for (const p of particles) {
      p.x += p.dx;
      p.y += p.dy;
      p.pulse += 0.02;
      if (p.y < -10) { p.y = H + 10; p.x = Math.random() * W; }
      if (p.x < -10) p.x = W + 10;
      if (p.x > W + 10) p.x = -10;
      const a = p.alpha * (0.5 + 0.5 * Math.sin(p.pulse));
      bc.fillStyle = `hsla(${p.hue}, 100%, 70%, ${a})`;
      bc.shadowColor = `hsla(${p.hue}, 100%, 70%, ${a})`;
      bc.shadowBlur = 10;
      bc.beginPath();
      bc.arc(p.x % W, p.y, p.r, 0, Math.PI * 2);
      bc.fill();
      bc.shadowBlur = 0;
    }

    // Subtle fog layer
    const fog = bc.createLinearGradient(0, H * 0.6, 0, H * 0.8);
    fog.addColorStop(0, 'rgba(0, 80, 120, 0)');
    fog.addColorStop(0.5, `rgba(0, 100, 150, ${0.04 + 0.02 * Math.sin(t)})`);
    fog.addColorStop(1, 'rgba(0, 80, 120, 0)');
    bc.fillStyle = fog;
    bc.fillRect(0, H * 0.6, W, H * 0.2);

    requestAnimationFrame(drawPandora);
  }
  drawPandora();
})();
</script>

<script>
const COLS = 10, ROWS = 20, BLOCK = 30;
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const nextCanvas = document.getElementById('next-canvas');
const nextCtx = nextCanvas.getContext('2d');

const COLORS = ['#00ff88','#00cc66','#33ff33','#00e676','#1b5e20','#4caf50','#76ff03'];
const PIECES = [
  [[1,1,1,1]],
  [[1,1],[1,1]],
  [[0,1,0],[1,1,1]],
  [[0,1,1],[1,1,0]],
  [[1,1,0],[0,1,1]],
  [[1,0,0],[1,1,1]],
  [[0,0,1],[1,1,1]]
];

let board, piece, pieceX, pieceY, pieceType, nextType, score, lines, level;
let dropInterval, dropTimer, gameOver, paused, started = false;

function createBoard() {
  return Array.from({length: ROWS}, () => Array(COLS).fill(0));
}

function randomType() { return Math.floor(Math.random() * PIECES.length); }

function rotateMatrix(m) {
  const r = m.length, c = m[0].length;
  const res = Array.from({length: c}, () => Array(r).fill(0));
  for (let i = 0; i < r; i++)
    for (let j = 0; j < c; j++)
      res[j][r - 1 - i] = m[i][j];
  return res;
}

function valid(b, p, px, py) {
  for (let r = 0; r < p.length; r++)
    for (let c = 0; c < p[r].length; c++)
      if (p[r][c]) {
        const nx = px + c, ny = py + r;
        if (nx < 0 || nx >= COLS || ny >= ROWS) return false;
        if (ny >= 0 && b[ny][nx]) return false;
      }
  return true;
}

function merge(b, p, px, py, t) {
  for (let r = 0; r < p.length; r++)
    for (let c = 0; c < p[r].length; c++)
      if (p[r][c] && py + r >= 0)
        b[py + r][px + c] = t + 1;
}

function clearLines() {
  let cleared = 0;
  for (let r = ROWS - 1; r >= 0; r--) {
    if (board[r].every(c => c)) {
      board.splice(r, 1);
      board.unshift(Array(COLS).fill(0));
      cleared++;
      r++;
    }
  }
  if (cleared) {
    const pts = [0, 100, 300, 500, 800];
    score += (pts[cleared] || 800) * level;
    lines += cleared;
    level = Math.floor(lines / 10) + 1;
    dropInterval = Math.max(50, 1000 - (level - 1) * 80);
    updateUI();
  }
}

function spawnPiece() {
  pieceType = nextType;
  nextType = randomType();
  piece = PIECES[pieceType].map(r => [...r]);
  pieceX = Math.floor((COLS - piece[0].length) / 2);
  pieceY = -piece.length;
  if (!valid(board, piece, pieceX, pieceY + 1) && pieceY >= -1) {
    gameOver = true;
    document.getElementById('game-over').style.display = 'block';
    document.getElementById('final-score').textContent = score;
  }
  drawNext();
}

function updateUI() {
  document.getElementById('score').textContent = score;
  document.getElementById('level').textContent = level;
  document.getElementById('lines').textContent = lines;
}

function drawBlock(c, x, y, size, context) {
  context.fillStyle = COLORS[c];
  context.fillRect(x * size + 1, y * size + 1, size - 2, size - 2);
  context.fillStyle = 'rgba(255,255,255,0.15)';
  context.fillRect(x * size + 1, y * size + 1, size - 2, 4);
  context.fillRect(x * size + 1, y * size + 1, 4, size - 2);
}

function drawGhost() {
  let gy = pieceY;
  while (valid(board, piece, pieceX, gy + 1)) gy++;
  ctx.globalAlpha = 0.2;
  for (let r = 0; r < piece.length; r++)
    for (let c = 0; c < piece[r].length; c++)
      if (piece[r][c] && gy + r >= 0) {
        ctx.fillStyle = COLORS[pieceType];
        ctx.fillRect((pieceX + c) * BLOCK + 1, (gy + r) * BLOCK + 1, BLOCK - 2, BLOCK - 2);
      }
  ctx.globalAlpha = 1;
}

function drawNext() {
  nextCtx.clearRect(0, 0, 80, 80);
  const p = PIECES[nextType];
  const ox = Math.floor((4 - p[0].length) / 2);
  const oy = Math.floor((4 - p.length) / 2);
  for (let r = 0; r < p.length; r++)
    for (let c = 0; c < p[r].length; c++)
      if (p[r][c]) drawBlock(nextType, ox + c, oy + r, 20, nextCtx);
}

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  // grid
  ctx.strokeStyle = '#1a1a1a';
  for (let r = 0; r <= ROWS; r++) { ctx.beginPath(); ctx.moveTo(0, r*BLOCK); ctx.lineTo(COLS*BLOCK, r*BLOCK); ctx.stroke(); }
  for (let c = 0; c <= COLS; c++) { ctx.beginPath(); ctx.moveTo(c*BLOCK, 0); ctx.lineTo(c*BLOCK, ROWS*BLOCK); ctx.stroke(); }
  // board
  for (let r = 0; r < ROWS; r++)
    for (let c = 0; c < COLS; c++)
      if (board[r][c]) drawBlock(board[r][c] - 1, c, r, BLOCK, ctx);
  // ghost + piece
  if (!gameOver && !paused) {
    drawGhost();
    for (let r = 0; r < piece.length; r++)
      for (let c = 0; c < piece[r].length; c++)
        if (piece[r][c] && pieceY + r >= 0)
          drawBlock(pieceType, pieceX + c, pieceY + r, BLOCK, ctx);
  }
  if (paused) {
    ctx.fillStyle = 'rgba(0,0,0,0.7)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = '#fff';
    ctx.font = '28px Courier New';
    ctx.textAlign = 'center';
    ctx.fillText('PAUSED', canvas.width/2, canvas.height/2);
  }
}

function drop() {
  if (valid(board, piece, pieceX, pieceY + 1)) {
    pieceY++;
  } else {
    merge(board, piece, pieceX, pieceY, pieceType);
    clearLines();
    spawnPiece();
  }
}

function moveLeft() { if (!paused && !gameOver && valid(board, piece, pieceX - 1, pieceY)) pieceX--; }
function moveRight() { if (!paused && !gameOver && valid(board, piece, pieceX + 1, pieceY)) pieceX++; }
function softDrop() { if (!paused && !gameOver) { drop(); score += 1; updateUI(); } }
function rotate() {
  if (paused || gameOver) return;
  const r = rotateMatrix(piece);
  // wall kick
  for (let offset of [0, -1, 1, -2, 2]) {
    if (valid(board, r, pieceX + offset, pieceY)) {
      piece = r;
      pieceX += offset;
      return;
    }
  }
}
function hardDrop() {
  if (paused || gameOver) return;
  while (valid(board, piece, pieceX, pieceY + 1)) { pieceY++; score += 2; }
  drop();
  updateUI();
}

let lastTime = 0;
function gameLoop(time) {
  if (!started) return;
  const dt = time - lastTime;
  lastTime = time;
  if (!gameOver && !paused) {
    dropTimer += dt;
    if (dropTimer >= dropInterval) {
      drop();
      dropTimer = 0;
    }
  }
  draw();
  requestAnimationFrame(gameLoop);
}

function startGame() {
  board = createBoard();
  score = 0; lines = 0; level = 1;
  dropInterval = 1000; dropTimer = 0;
  gameOver = false; paused = false;
  nextType = randomType();
  spawnPiece();
  updateUI();
  document.getElementById('start-screen').style.display = 'none';
  document.getElementById('game-over').style.display = 'none';
  document.getElementById('game-area').style.visibility = 'visible';
  if (!started) {
    started = true;
    lastTime = performance.now();
    requestAnimationFrame(gameLoop);
  }
}

document.addEventListener('keydown', e => {
  if (!started || gameOver) return;
  switch(e.key) {
    case 'ArrowLeft': moveLeft(); break;
    case 'ArrowRight': moveRight(); break;
    case 'ArrowDown': softDrop(); break;
    case 'ArrowUp': rotate(); break;
    case ' ': hardDrop(); e.preventDefault(); break;
    case 'p': case 'P': paused = !paused; break;
  }
  draw();
});
</script>
</body>
</html>
